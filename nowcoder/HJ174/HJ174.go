/*
HJ174 交换到最大

描述
给定一个仅由数字
0-9
0-9 构成的字符串
s
s。一次操作可按如下方式进行：
∙

∙ 从
s
s 中选择既不是最左端字符也不为
0
0 的某一字符；
∙

∙ 将该字符的数值减少
1
1；
∙

∙ 随后把它与左侧相邻字符交换位置。

例如，字符串
"1023"
"1023" 经过一次操作可以变成
"1103"
"1103" 或
"1022"
"1022"。

你可以不限次数地执行上述操作。请计算能够得到的字典序最大的字符串，并输出该字符串。
输入描述：
第一行输入一个整数
t
(
1
≦
t
≦
1
0
4
)
t(1≦t≦10
4
 )，表示测试用例数量。
此后
t
t 行，每行输入一个不含前导零的数字字符串
s
s，满足
1
≦
∣
s
∣
≦
2
×
1
0
5
1≦∣s∣≦2×10
5
 。
保证所有测试用例的
∣
s
∣
∣s∣ 之和不超过
2
×
1
0
5
2×10
5
 。
输出描述：
对于每个测试用例，在一行上输出通过任意次数操作后能够得到的字典序最大的字符串。
示例1
输入：
6
19
1709
11555
51476
9876543210
5891917899
复制
输出：
81
6710
33311
55431
9876543210
7875567711
复制
说明：
以
"19"
"19" 为例：
∙

∙
"19"
"19"
→
→
"89"
"89"；
∙

∙
"89"
"89"
→
→
"81"
"81"，得到答案
"81"
"81"。

再以
"1709"
"1709" 为例，可按如下序列操作：
∙

∙
"1709"
"1709"
→
→
"1780"
"1780"；
∙

∙
"1780"
"1780"
→
→
"6180"
"6180"；
∙

∙
"6180"
"6180"
→
→
"6710"
"6710"，最终得到答案
"6710"
"6710"。
*/

package main

import (
	"bufio"
	"io"
	"os"
	"strconv"
)

func main() {
	// 这个地方的输入要处理的尤其小心
	// 最大的问题在于，Scanner有缓冲限制，如果输入数据量过大，会导致输入数据被截断
	// 用fmt.Scanf可以解决这个问题，但是性能又不行
	// 因此采用bufio.Reader来读取输入，并且使用ReadString来读取一行数据
	// 该函数在代码层面解决了一行输入数据量过大导致的问题
	// 但是需要手动处理结尾符号，包括换行符和EOF
	in := bufio.NewReader(os.Stdin)
	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()

	s, _ := in.ReadString('\n')
	t, _ := strconv.Atoi(s[:len(s)-1])

	getMax := func(s string) string {
		li := []byte(s)
		for i := 1; i < len(li); i++ {
			if li[i] == '0' {
				continue
			}

			for j := i; j > 0; j-- {
				right := int(li[j] - '0')
				left := int(li[j-1] - '0')
				if right-1 > left {
					li[j-1], li[j] = byte(right-1+'0'), li[j-1]
				} else {
					break
				}
			}
		}
		return string(li)
	}

	for t > 0 {
		t--
		s, err := in.ReadString('\n')
		if err != nil {
			if err == io.EOF {
				s += "\n"
			} else {
				panic(err)
			}
		}
		out.WriteString(getMax(s[:len(s)-1]) + "\n")
	}
}
