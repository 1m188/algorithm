/*
BISHI131 数楼梯

描述
给定一段有
n
n 阶的楼梯，你每一步可以选择上
1
1 阶或者
2
2 阶。求从楼梯底端走到顶端共有多少种不同的走法。由于答案可能很大，请将结果对
998

244

353
998244353 取模后输出。
输入描述：
在一行上输入一个整数
n
(
1
≦
n
≦
1
0
5
)
n(1≦n≦10
5
 )，表示楼梯的阶数。
输出描述：
输出一个整数，表示不同走法的数量，对
998

244

353
998244353 取模后的结果。
示例1
输入：
1
复制
输出：
1
复制
说明：
当
n
=
1
n=1 时，只能一步到顶端，共
1
1 种走法。
示例2
输入：
4
复制
输出：
5
复制
说明：
当
n
=
4
n=4 时，五种走法分别为：
∙

∙
1
+
1
+
1
+
1
1+1+1+1；
∙

∙
1
+
1
+
2
1+1+2；
∙

∙
1
+
2
+
1
1+2+1；
∙

∙
2
+
1
+
1
2+1+1；
∙

∙
2
+
2
2+2。
示例3
输入：
721
复制
输出：
670483856
复制
备注：
提示，取模运算对加法运算满足交换律和结合律，所以在计算过程中多次取模得到的计算结果，和全部计算都完成后得到的计算结果是相同的。
*/

package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"
)

func main() {
	const MOD = 998244353

	data, _ := ioutil.ReadAll(os.Stdin)
	n, _ := strconv.Atoi(strings.TrimSpace(string(data)))

	switch n {
	case 1:
		fmt.Println(1)
	case 2:
		fmt.Println(2)
	default:
		dp := make([]uint64, n+1)
		dp[1], dp[2] = 1, 2
		for i := 3; i <= n; i++ {
			dp[i] = (dp[i-1] + dp[i-2]) % MOD
		}
		fmt.Println(dp[n])
	}
}
