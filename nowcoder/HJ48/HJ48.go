/*
HJ48 从单向链表中删除指定值的节点

描述
定义一种单向链表的构造方法如下所示：
∙

∙先输入一个整数
n
n ，代表链表中节点的总数；
∙

∙再输入一个整数
h
h ，代表头节点的值；
∙

∙此后输入
n
−
1
n−1 个二元组
(
a
,
b
)
(a,b) ，表示在值为
b
b 的节点后插入值为
a
a 的节点。
除此之外，保证输入的链表中不存在重复的节点值。

现在，对于给定的链表构造方法和一个额外的整数
k
k ，你需要先按照上述构造方法构造出链表，随后删除值为
k
k 的节点，输出剩余的链表。
输入描述：
在一行上：
1.

1.
​
 先输入一个整数
n
(
1
≦
n
≦
1
0
3
)
n(1≦n≦10
3
 ) 代表链表中节点的总数；
2.

2.
​
 随后输入一个整数
h
(
1
≦
h
≦
1
0
4
)
h(1≦h≦10
4
 ) 代表头节点的值；
3.

3.
​
 随后输入
n
−
1
n−1 个二元组
(
a
,
b
)
(
1
≦
a
,
b
≦
1
0
4
)
(a,b)(1≦a,b≦10
4
 ) ；
4.

4.
​
 最后输入一个整数
k
k ，代表需要删除的节点值。

除此之外，保证每一个
b
b 值在输入前已经存在于链表中；每一个
a
a 值在输入前均不存在于链表中。节点的值各不相同。
输出描述：
在一行上输出
n
−
1
n−1 个整数，代表删除指定元素后剩余的链表。
示例1
输入：
5 2 3 2 4 3 5 2 1 4 3
复制
输出：
2 5 4 1
复制
说明：
在这个样例中，链表的构造过程如下：
∙

∙头节点为
2
2 ，得到链表
[
2
]
[2] ；
∙

∙在
2
2 后插入
3
3 ，得到链表
[
2
,
3
]
[2,3] ；
∙

∙在
3
3 后插入
4
4 ，得到链表
[
2
,
3
,
4
]
[2,3,4] ；
∙

∙在
2
2 后插入
5
5 ，得到链表
[
2
,
5
,
3
,
4
]
[2,5,3,4] ；
∙

∙在
4
4 后插入
1
1 ，得到链表
[
2
,
5
,
3
,
4
,
1
]
[2,5,3,4,1] ；
随后，删除值为
3
3 的节点，得到链表
[
2
,
5
,
4
,
1
]
[2,5,4,1] 。
示例2
输入：
6 2 1 2 3 2 5 1 4 5 7 2 2
复制
输出：
7 3 1 5 4
复制
说明：
在这个样例中，链表的构造过程如下：
∙

∙头节点为
2
2 ，得到链表
[
2
]
[2] ；
∙

∙在
2
2 后插入
1
1 ，得到链表
[
2
,
1
]
[2,1] ；
∙

∙在
2
2 后插入
3
3 ，得到链表
[
2
,
3
,
1
]
[2,3,1] ；
∙

∙在
1
1 后插入
5
5 ，得到链表
[
2
,
3
,
1
,
5
]
[2,3,1,5] ；
∙

∙在
5
5 后插入
4
4 ，得到链表
[
2
,
3
,
1
,
5
,
4
]
[2,3,1,5,4] ；
∙

∙在
2
2 后插入
7
7 ，得到链表
[
2
,
7
,
3
,
1
,
5
,
4
]
[2,7,3,1,5,4] ；
随后，删除值为
2
2 的节点，得到链表
[
7
,
3
,
1
,
5
,
4
]
[7,3,1,5,4] 。
备注：
本题由牛客重构过题面，您可能想要阅读原始题面，我们一并附于此处。
【以下为原始题面】
输入一个单向链表和一个节点的值，从单向链表中删除等于该值的节点，删除后如果链表中无节点则返回空指针。

链表的值不能重复。

构造过程，例如输入一行数据为:
6 2 1 2 3 2 5 1 4 5 7 2 2
则第一个参数6表示输入总共6个节点，第二个参数2表示头节点值为2，剩下的2个一组表示第2个节点值后面插入第1个节点值，为以下表示:
1 2 表示为
2->1
链表为2->1

3 2表示为
2->3
链表为2->3->1

5 1表示为
1->5
链表为2->3->1->5

4 5表示为
5->4
链表为2->3->1->5->4

7 2表示为
2->7
链表为2->7->3->1->5->4

最后的链表的顺序为 2 7 3 1 5 4

最后一个参数为2，表示要删掉节点为2的值
删除 结点 2

则结果为 7 3 1 5 4

数据范围：链表长度满足
1
≤
n
≤
1000

1≤n≤1000  ，节点中的值满足
0
≤
v
a
l
≤
10000

0≤val≤10000

测试用例保证输入合法
*/

package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
)

func main() {
	in := bufio.NewScanner(os.Stdin)
	in.Split(bufio.ScanWords)
	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()

	in.Scan()
	n, _ := strconv.Atoi(in.Text())
	li := make([]int, 1e4+10)

	in.Scan()
	h, _ := strconv.Atoi(in.Text())

	for i := 0; i < n-1; i++ {
		in.Scan()
		a, _ := strconv.Atoi(in.Text())
		in.Scan()
		b, _ := strconv.Atoi(in.Text())
		if li[b] == 0 {
			li[b] = a
		} else {
			next := li[b]
			li[b] = a
			li[a] = next
		}
	}

	in.Scan()
	k, _ := strconv.Atoi(in.Text())

	if k == h {
		h = li[h]
	} else {
		node := h
		for node != 0 {
			next := li[node]
			if next != k {
				node = next
				continue
			}
			nnext := li[next]
			li[node] = nnext
			break
		}
	}

	fmt.Fprintf(out, "%d", h)
	for node := li[h]; node != 0; node = li[node] {
		fmt.Fprintf(out, " %d", node)
	}
}
