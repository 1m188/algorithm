/*
HJ69 矩阵乘法

描述
对于给定的
x
x 行
y
y 列的矩阵：
A
=
[
A
1
,
1
A
1
,
2
⋯
A
1
,
y
A
2
,
1
A
2
,
2
⋯
A
2
,
y
⋮
⋮
⋱
⋮
A
x
,
1
A
x
,
2
⋯
A
x
,
y
]
A=
⎣
⎢
⎢
⎢
⎡
​

A
1,1
​

A
2,1
​

⋮
A
x,1
​

​

A
1,2
​

A
2,2
​

⋮
A
x,2
​

​

⋯
⋯
⋱
⋯
​

A
1,y
​

A
2,y
​

⋮
A
x,y
​

​

⎦
⎥
⎥
⎥
⎤
​

和
y
y 行
z
z 列的矩阵：
B
=
[
B
1
,
1
B
1
,
2
⋯
B
1
,
z
B
2
,
1
B
2
,
2
⋯
B
2
,
z
⋮
⋮
⋱
⋮
B
y
,
1
B
y
,
2
⋯
B
y
,
z
]
B=
⎣
⎢
⎢
⎢
⎡
​

B
1,1
​

B
2,1
​

⋮
B
y,1
​

​

B
1,2
​

B
2,2
​

⋮
B
y,2
​

​

⋯
⋯
⋱
⋯
​

B
1,z
​

B
2,z
​

⋮
B
y,z
​

​

⎦
⎥
⎥
⎥
⎤
​

计算矩阵
A
A 和矩阵
B
B 的乘积
C
C。

让我们回忆矩阵乘法的计算，对于第
i
i 行第
j
j 列的元素
C
i
,
j
(
1
≦
i
≦
x
;

1
≦
j
≦
z
)
C
i,j
​
 (1≦i≦x; 1≦j≦z)，有：
C
i
,
j
=
∑
k
=
1
y
(
A
i
,
k
×
B
k
,
j
)
C
i,j
​
 =
k=1
∑
y
​
 (A
i,k
​
 ×B
k,j
​
 )
输入描述：
第一行输入一个整数
x
(
1
≦
x
≦
100
)
x(1≦x≦100) 代表第一个矩阵的行数。
第二行输入一个整数
y
(
1
≦
y
≦
100
)
y(1≦y≦100) 代表第一个矩阵的列数和第二个矩阵的行数。
第三行输入一个整数
z
(
1
≦
z
≦
100
)
z(1≦z≦100) 代表第二个矩阵的列数。
此后
x
x 行，第
i
i 行输入
y
y 个整数
A
i
,
1
,
A
i
,
2
,
…
,
A
i
,
y
(
0
≦
A
i
,
j
≦
10
)
A
i,1
​
 ,A
i,2
​
 ,…,A
i,y
​
 (0≦A
i,j
​
 ≦10) 代表矩阵
A
A 的第
i
i 行元素。
此后
y
y 行，第
i
i 行输入
z
z 个整数
B
i
,
1
,
B
i
,
2
,
…
,
B
i
,
z
(
0
≦
B
i
,
j
≦
10
)
B
i,1
​
 ,B
i,2
​
 ,…,B
i,z
​
 (0≦B
i,j
​
 ≦10) 代表矩阵
B
B 的第
i
i 行元素。
输出描述：
输出
x
x 行，第
i
i 行输出
z
z 个整数，代表矩阵
C
C 的第
i
i 行元素。
示例1
输入：
2
3
2
1 2 3
3 2 1
1 2
2 1
3 3
复制
输出：
14 13
10 11
复制
说明：
在这个样例中，
C
=
[
A
1
,
1
B
1
,
1
+
A
1
,
2
B
2
,
1
+
A
1
,
3
B
3
,
1
A
1
,
1
B
1
,
2
+
A
1
,
2
B
2
,
2
+
A
1
,
3
B
3
,
2
A
2
,
1
B
1
,
1
+
A
2
,
2
B
2
,
1
+
A
2
,
3
B
3
,
1
A
2
,
1
B
1
,
2
+
A
2
,
2
B
2
,
2
+
A
2
,
3
B
3
,
2
]
=
[
1
×
1
+
2
×
2
+
3
×
3
1
×
2
+
2
×
1
+
3
×
3
3
×
1
+
2
×
2
+
1
×
3
3
×
2
+
2
×
1
+
1
×
3
]
=
[
1
+
4
+
9
2
+
2
+
9
3
+
4
+
1
6
+
2
+
3
]
=
[
14
13
10
11
]
C
​

=[
A
1,1
​
 B
1,1
​
 +A
1,2
​
 B
2,1
​
 +A
1,3
​
 B
3,1
​

A
2,1
​
 B
1,1
​
 +A
2,2
​
 B
2,1
​
 +A
2,3
​
 B
3,1
​

​

A
1,1
​
 B
1,2
​
 +A
1,2
​
 B
2,2
​
 +A
1,3
​
 B
3,2
​

A
2,1
​
 B
1,2
​
 +A
2,2
​
 B
2,2
​
 +A
2,3
​
 B
3,2
​

​
 ]
=[
1×1+2×2+3×3
3×1+2×2+1×3
​

1×2+2×1+3×3
3×2+2×1+1×3
​
 ]
=[
1+4+9
3+4+1
​

2+2+9
6+2+3
​
 ]
=[
14
10
​

13
11
​
 ]
​
 。
示例2
输入：
16
8
7
17 19 16 19 14 1 14 9
7 2 7 9 16 14 16 12
13 3 3 17 5 9 8 16
1 14 16 10 13 13 14 1
13 13 15 4 7 2 6 16
16 15 5 5 15 13 1 11
11 5 0 16 14 7 7 15
0 16 4 7 16 6 0 15
2 14 11 2 17 17 5 12
8 13 11 10 1 17 10 8
15 16 17 15 7 8 13 14
5 19 11 3 11 14 5 4
9 16 13 11 15 18 0 3
15 3 19 9 5 14 12 3
9 8 7 11 18 19 14 18
12 19 9 1 0 18 17 10
5 18 16 19 6 12 5
1 17 1 5 9 16 3
14 16 4 0 19 3 6
11 9 15 18 11 17 13
5 5 19 3 16 1 12
12 13 19 1 10 5 18
19 18 6 18 19 12 3
15 11 6 5 10 17 19
复制
输出：
1020 1490 1063 1100 1376 1219 884
966 1035 1015 715 1112 772 920
822 948 888 816 831 920 863
855 1099 828 578 1160 717 724
745 1076 644 595 930 838 688
635 1051 970 600 880 811 846
748 879 952 772 864 872 878
526 722 645 335 763 688 748
764 996 868 362 1026 681 897
836 1125 785 637 940 849 775
1082 1476 996 968 1301 1183 953
609 987 717 401 894 657 662
700 1083 1022 527 1016 746 875
909 1162 905 722 1055 708 720
1126 1296 1240 824 1304 1031 1196
905 1342 766 715 1028 956 749
*/

package main

import (
	"bufio"
	"os"
	"strconv"
)

func main() {
	in := bufio.NewScanner(os.Stdin)
	in.Split(bufio.ScanWords)
	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()

	in.Scan()
	x, _ := strconv.Atoi(in.Text())

	in.Scan()
	y, _ := strconv.Atoi(in.Text())

	in.Scan()
	z, _ := strconv.Atoi(in.Text())

	A := make([][]int, x)
	for i := 0; i < x; i++ {
		A[i] = make([]int, y)
		for j := 0; j < y; j++ {
			in.Scan()
			A[i][j], _ = strconv.Atoi(in.Text())
		}
	}

	B := make([][]int, y)
	for i := 0; i < y; i++ {
		B[i] = make([]int, z)
		for j := 0; j < z; j++ {
			in.Scan()
			B[i][j], _ = strconv.Atoi(in.Text())
		}
	}

	C := make([][]int, x)
	for i := 0; i < x; i++ {
		C[i] = make([]int, z)
		for j := 0; j < z; j++ {
			for k := 0; k < y; k++ {
				C[i][j] += A[i][k] * B[k][j]
			}
		}
	}

	for i := 0; i < x; i++ {
		for j := 0; j < z; j++ {
			out.WriteString(strconv.Itoa(C[i][j]) + " ")
		}
		out.WriteString("\n")
	}
}
