/*
HJ45 名字的漂亮度

描述
对于给定由小写字母构成的字符串，定义字符串的“漂亮度”为该字符串中所有字母“漂亮度”的总和。
每一个字母的“漂亮度”将由你来确定，具体规则如下：
∙

∙每一个字母的“漂亮度”为
1
1 到
26
26 之间的整数；
∙

∙没有两个字母的“漂亮度”相同。
现在，你需要确定每个字母的“漂亮度”，以使得字符串的“漂亮度”最大。
输入描述：
每个测试文件均包含多组测试数据。第一行输入一个整数
T
(
1
≦
T
≦
10
)
T(1≦T≦10) 代表数据组数，每组测试数据描述如下：

在一行上输入一个长度为
1
≦
l
e
n
(
s
)
≦
1
0
4
1≦len(s)≦10
4
  、仅由小写字母构成的字符串
s
s 。
输出描述：
对于每一组测试数据，输出一个整数，表示字符串的最大“漂亮度”。
示例1
输入：
2
zhangsan
lisi
复制
输出：
192
101
复制
说明：
对于第一组测试数据，其中一种最优的分配方案是：
∙

∙将字符
‘a’
‘a’ 的漂亮度分配为
26
26 ；
∙

∙将字符
‘n’
‘n’ 的漂亮度分配为
25
25 ；
∙

∙将字符
‘g’
,
‘z’
,
‘h’
,
‘s’
‘g’,‘z’,‘h’,‘s’ 的漂亮度依次分配为
24
∼
21
24∼21 ；
∙

∙其余字符随意分配；
最终，得到字符串的“漂亮度”为
(
26
+
25
)
×
2
+
(
24
+
23
+
22
+
21
)
=
192
(26+25)×2+(24+23+22+21)=192 。

对于第二组测试数据，其中一种最优的分配方案是：
∙

∙将字符
‘i’
‘i’ 的漂亮度分配为
26
26 ；
∙

∙将字符
‘l’
‘l’ 的漂亮度分配为
25
25 ；
∙

∙将字符
‘s’
‘s’ 的漂亮度分配为
24
24 ；
∙

∙其余字符随意分配；
最终，得到字符串的“漂亮度”为
26
×
2
+
(
25
+
24
)
=
101
26×2+(25+24)=101 。
*/

package main

import (
	"fmt"
	"sort"
)

func getBeauty(s string) int {
	mmap := make([][]int, 26)
	for i := 0; i < 26; i++ {
		mmap[i] = make([]int, 2)
		mmap[i][0] = i
	}
	for _, v := range []byte(s) {
		mmap[v-'a'][1]++
	}
	sort.Slice(mmap, func(i, j int) bool {
		return mmap[i][1] > mmap[j][1]
	})

	res := 0
	val := 26
	for i := 0; i < 26; i++ {
		if mmap[i][1] == 0 {
			break
		}
		res += mmap[i][1] * val
		val--
	}
	return res
}

func main() {

	T := 0
	fmt.Scan(&T)

	for T > 0 {
		T--
		var s string
		fmt.Scan(&s)
		fmt.Println(getBeauty(s))
	}

}
