/*
BISHI1 【模板】序列操作

描述
你需要维护一个初始为空的整数序列，支持以下 8 种操作：
1.

1.
​
 输入格式为 `1 x`，表示向序列末尾增加一个整数
x
(
1
≦
x
≦
1
0
9
)
x(1≦x≦10
9
 )；
2.

2.
​
 输入格式为 `2`，表示删除序列末尾的元素（保证此时序列非空）；
3.

3.
​
 输入格式为 `3 i`，表示输出序列中下标为
i
i（起始下标为
0
0）的元素；
4.

4.
​
 输入格式为 `4 i x`，表示在下标为
i
i 的元素与下标为
i
+
1
i+1 的元素之间插入整数
x
x（起始下标为
0
0，
0
≦
i
<
∣
序列
∣
,
1
≦
x
≦
1
0
9
0≦i<∣序列∣,1≦x≦10
9
 ）；
5.

5.
​
 输入格式为 `5`，表示将序列按照从小到大升序排序；
6.

6.
​
 输入格式为 `6`，表示将序列按照从大到小降序排序；
7.

7.
​
 输入格式为 `7`，表示输出当前序列的长度；
8.

8.
​
 输入格式为 `8`，表示输出当前整个序列。
输入描述：
第一行输入一个整数
q
q
(
1
≦
q
≦
7
×
1
0
3
)
(1≦q≦7×10
3
 )，表示操作总次数。
接下来
q
q 行，每行输入一种操作，格式如题目描述所示。
输出描述：
对于每次操作类型 3，在一行输出对应的元素；
对于每次操作类型 7，在一行输出当前序列的长度；
对于每次操作类型 8，在一行输出由当前序列所有元素组成的序列，元素之间用空格分隔。
示例1
输入：
5
1 8
1 9
7
1 6
8
复制
输出：
2
8 9 6
复制
说明：
∙

∙操作 `1 8` 后序列为
{
8
}
{8}；
∙

∙操作 `1 9` 后序列为
{
8
,
9
}
{8,9}；
∙

∙操作 `7` 输出长度
2
2；
∙

∙操作 `1 6` 后序列为
{
8
,
9
,
6
}
{8,9,6}；
∙

∙操作 `8` 输出序列 `8 9 6`。
示例2
输入：
8
1 5
1 3
1 7
3 1
4 1 4
8
5
8
复制
输出：
3
5 3 4 7
3 4 5 7
复制
说明：
∙

∙序列依次变为
{
5
}
,
{
5
,
3
}
,
{
5
,
3
,
7
}
{5},{5,3},{5,3,7}；
∙

∙操作 `3 1` 输出下标
1
1 的元素
3
3；
∙

∙操作 `4 1 4` 在下标
1
1 与
2
2 之间插入
4
4，序列变为
{
5
,
3
,
4
,
7
}
{5,3,4,7}；
∙

∙操作 `8` 输出序列 `5 3 4 7`；
∙

∙操作 `5` 升序排序后序列变为
{
3
,
4
,
5
,
7
}
{3,4,5,7}；
∙

∙操作 `8` 输出序列 `3 4 5 7`。
*/

package main

import (
	"fmt"
	"sort"
)

func main() {

	q := 0
	fmt.Scan(&q)

	seq := make([]int, 0, 7000+10)

	for q > 0 {
		q--

		var op int
		fmt.Scan(&op)

		switch op {
		case 1:
			x := 0
			fmt.Scan(&x)
			seq = append(seq, x)
		case 2:
			seq = seq[:len(seq)-1]
		case 3:
			var i int
			fmt.Scan(&i)
			fmt.Println(seq[i])
		case 4:
			var i, x int
			fmt.Scan(&i, &x)
			seq = append(seq[:i+1], append([]int{x}, seq[i+1:]...)...)
		case 5:
			sort.Ints(seq)
		case 6:
			sort.Slice(seq, func(i, j int) bool { return seq[i] > seq[j] })
		case 7:
			fmt.Println(len(seq))
		case 8:
			if len(seq) > 0 {
				fmt.Print(seq[0])
				for i := 1; i < len(seq); i++ {
					fmt.Printf(" %d", seq[i])
				}
				fmt.Println()
			}
		}
	}

}
